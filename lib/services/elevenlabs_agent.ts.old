/**
 * ElevenLabs AI Producer Service
 * Manages WebSocket connection to ElevenLabs Conversational AI Agent
 * for real-time answer evaluation
 */

export interface ElevenLabsConfig {
  agentId: string;
  apiKey: string;
}

export interface AIProducerResponse {
  decision: 'APPROVED' | 'FOLLOW_UP';
  followUpText?: string;
  reasoning?: string;
}

export type AIProducerCallback = (response: AIProducerResponse) => void;

export class ElevenLabsAIProducer {
  private ws: WebSocket | null = null;
  private config: ElevenLabsConfig;
  private sessionId: string;
  private currentQuestionId: string | null = null;
  private onDecisionCallback: AIProducerCallback | null = null;
  private audioChunks: Blob[] = [];

  constructor(config: ElevenLabsConfig, sessionId: string) {
    this.config = config;
    this.sessionId = sessionId;
  }

  /**
   * Initialize WebSocket connection to ElevenLabs
   */
  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        // Use our backend proxy instead of direct connection
        const wsUrl = `/api/elevenlabs/ws?session_id=${this.sessionId}`;
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;

        this.ws = new WebSocket(`${protocol}//${host}${wsUrl}`);

        this.ws.onopen = () => {
          console.log('‚úÖ ElevenLabs AI Producer connected');
          resolve();
        };

        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };

        this.ws.onerror = (error) => {
          console.error('‚ùå ElevenLabs WebSocket error:', error);
          reject(error);
        };

        this.ws.onclose = () => {
          console.log('üîå ElevenLabs WebSocket closed');
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Set the current question being answered
   */
  setCurrentQuestion(questionId: string, questionText: string): void {
    this.currentQuestionId = questionId;
    this.audioChunks = [];

    // Send question context to backend
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        type: 'set_question',
        question_id: questionId,
        question_text: questionText,
      }));
    }
  }

  /**
   * Stream audio chunk to ElevenLabs
   */
  streamAudioChunk(audioBlob: Blob): void {
    this.audioChunks.push(audioBlob);

    // Convert to base64 and send via WebSocket
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64Audio = (reader.result as string).split(',')[1];

      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({
          type: 'audio_chunk',
          audio: base64Audio,
          question_id: this.currentQuestionId,
        }));
      }
    };
    reader.readAsDataURL(audioBlob);
  }

  /**
   * Signal end of user's answer and request evaluation
   */
  async evaluateAnswer(onDecision: AIProducerCallback): Promise<void> {
    this.onDecisionCallback = onDecision;

    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      // Send end_of_turn signal
      this.ws.send(JSON.stringify({
        type: 'end_of_turn',
        question_id: this.currentQuestionId,
      }));

      console.log('ü§ñ AI Producer is evaluating answer...');
    } else {
      throw new Error('WebSocket not connected');
    }
  }

  /**
   * Handle incoming messages from ElevenLabs
   */
  private handleMessage(data: string): void {
    try {
      const message = JSON.parse(data);

      switch (message.type) {
        case 'decision':
          // ElevenLabs made a decision about the answer
          const response: AIProducerResponse = {
            decision: message.decision,
            followUpText: message.follow_up_text,
            reasoning: message.reasoning,
          };

          console.log('üéØ AI Producer decision:', response);

          if (this.onDecisionCallback) {
            this.onDecisionCallback(response);
          }
          break;

        case 'agent_response':
          // Text response from agent (follow-up question)
          console.log('üí¨ Agent response:', message.text);
          break;

        case 'error':
          console.error('‚ùå ElevenLabs error:', message.error);
          break;

        default:
          console.log('üì® ElevenLabs message:', message);
      }
    } catch (error) {
      console.error('Failed to parse ElevenLabs message:', error);
    }
  }

  /**
   * Close WebSocket connection
   */
  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  /**
   * Get connection status
   */
  isConnected(): boolean {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
}
