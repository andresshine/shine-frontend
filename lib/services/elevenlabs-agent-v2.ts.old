/**
 * ElevenLabs Conversational AI Agent Service - V2 REFACTOR
 * Clean implementation using direct WebSocket connection with proper overrides
 */

import WebSocket from 'ws';

const ELEVENLABS_API_KEY = process.env.ELEVENLABS_API_KEY || '';
const AGENT_ID = process.env.ELEVENLABS_AGENT_ID || '';

export interface AgentEvaluationResponse {
  decision: 'APPROVED' | 'FOLLOW_UP';
  followUpText?: string;
  reasoning: string;
  score?: number;
}

interface QuestionCriteria {
  text: string;
  criteria: string[];
}

/**
 * First message greeting
 */
const FIRST_MESSAGE = `Hi there! Thanks for taking the time to share your experience.

I'll guide you through a series of questions. For each one, please click Start Recording and answer using your voice. If possible, try to look at the camera while recording.

I'll review each response to make sure the question was fully answered. If anything needs clarification, I may ask a brief follow-up. Otherwise, we'll move on to the next question.

If you're not happy with an answer, you can always click Redo Question to record it again.

Let me know if everything makes sense. When you're ready, we can begin the interview.`;

/**
 * Evaluation-specific system prompt template
 */
const EVALUATION_SYSTEM_PROMPT = `# Role
You are an AI interview evaluator for Shine. Your job is to evaluate if a candidate's answer to an interview question is complete and satisfactory.

# Instructions
You will receive:
1. A question
2. Evaluation criteria for that question
3. The candidate's transcript

Your job:
- Evaluate if the answer addresses ALL criteria
- If YES ‚Üí Return APPROVED with score
- If NO ‚Üí Return FOLLOW_UP with a specific follow-up question

# Response Format
You MUST respond with ONLY valid JSON in this exact format:
{
  "decision": "APPROVED" or "FOLLOW_UP",
  "reasoning": "brief explanation",
  "followUpText": "specific follow-up question (only if FOLLOW_UP)",
  "score": 0-100
}

CRITICAL: Return ONLY the JSON object, no markdown, no explanation, no other text.`;

/**
 * Get signed WebSocket URL from ElevenLabs
 */
async function getSignedUrl(): Promise<string> {
  const response = await fetch(
    `https://api.elevenlabs.io/v1/convai/conversation/get-signed-url?agent_id=${AGENT_ID}`,
    {
      headers: {
        'xi-api-key': ELEVENLABS_API_KEY,
      },
    }
  );

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Failed to get signed URL: ${JSON.stringify(error)}`);
  }

  const data = await response.json();
  return data.signed_url;
}

/**
 * Evaluate answer using ElevenLabs Agent via WebSocket
 */
export async function evaluateWithAgent(
  questionText: string,
  candidateAnswer: string,
  questionCriteria: string[]
): Promise<AgentEvaluationResponse> {

  console.log('ü§ñ Starting ElevenLabs Agent evaluation (V2)...');

  return new Promise(async (resolve, reject) => {
    let ws: WebSocket | null = null;
    let agentResponse = '';
    let hasReceivedResponse = false;

    try {
      // Get WebSocket signed URL
      console.log('üì° Getting signed WebSocket URL...');
      const signedUrl = await getSignedUrl();

      // Create WebSocket connection
      console.log('üîå Connecting to ElevenLabs WebSocket...');
      ws = new WebSocket(signedUrl);

      // Timeout handler
      const timeout = setTimeout(() => {
        if (!hasReceivedResponse) {
          console.warn('‚ö†Ô∏è Agent timeout after 10 seconds');
          ws?.close();
          resolve({
            decision: 'APPROVED',
            reasoning: 'Agent timeout, auto-approved',
            score: 75,
          });
        }
      }, 10000);

      ws.on('open', () => {
        console.log('‚úÖ WebSocket connected');

        // Send conversation initiation with FULL CONFIG OVERRIDE
        const initiationPayload = {
          type: 'conversation_initiation_client_data',
          conversation_config_override: {
            agent: {
              prompt: {
                prompt: EVALUATION_SYSTEM_PROMPT,
                llm: 'gemini-2.5-flash',
                temperature: 0,
              },
              first_message: FIRST_MESSAGE, // Set greeting message
            },
            conversation: {
              text_only: false, // ENABLE VOICE OUTPUT
            },
          },
        };

        console.log('üì§ Sending conversation config override...');
        console.log('Config:', JSON.stringify(initiationPayload, null, 2));

        ws!.send(JSON.stringify(initiationPayload));

        // Wait a moment for session to initialize
        setTimeout(() => {
          // Build evaluation request
          const evaluationMessage = `
Question: "${questionText}"

Evaluation Criteria:
${questionCriteria.map((c, i) => `${i + 1}. ${c}`).join('\n')}

Candidate's Answer: "${candidateAnswer}"

Evaluate now and return JSON only.`;

          // Send user message
          console.log('üì§ Sending evaluation request...');
          ws!.send(JSON.stringify({
            type: 'user_message',
            text: evaluationMessage,
          }));
        }, 1000);
      });

      ws.on('message', (data: WebSocket.Data) => {
        try {
          // Handle binary audio data
          if (Buffer.isBuffer(data)) {
            console.log('üîä Received audio chunk:', data.length, 'bytes');
            // Audio chunks are received but we're primarily interested in text response for evaluation
            return;
          }

          const message = JSON.parse(data.toString());

          console.log('üì• Received message type:', message.type);

          // Agent response (text)
          if (message.type === 'agent_response') {
            console.log('üì• Agent response chunk:', message.text);
            agentResponse += message.text + ' ';
          }

          // Audio response
          if (message.type === 'audio') {
            console.log('üîä Audio message received');
            // Audio is being sent but we focus on text for evaluation
          }

          // Conversation complete or agent done speaking
          if (message.type === 'agent_response_complete' || message.type === 'conversation_complete') {
            hasReceivedResponse = true;
            clearTimeout(timeout);
            ws?.close();

            // Parse the response
            console.log('üì• Full agent response:', agentResponse);

            try {
              // Remove markdown code blocks
              let cleaned = agentResponse
                .replace(/```json\s*/g, '')
                .replace(/```\s*/g, '')
                .trim();

              // Extract JSON
              const jsonMatch = cleaned.match(/\{[\s\S]*\}/);

              if (jsonMatch) {
                const evaluation: AgentEvaluationResponse = JSON.parse(jsonMatch[0]);
                console.log('‚úÖ Parsed evaluation:', evaluation);

                if (evaluation.decision === 'APPROVED' || evaluation.decision === 'FOLLOW_UP') {
                  resolve(evaluation);
                  return;
                }
              }

              // Fallback
              console.warn('‚ö†Ô∏è Could not parse agent response');
              resolve({
                decision: 'APPROVED',
                reasoning: 'Could not parse response: ' + agentResponse.substring(0, 100),
                score: 75,
              });

            } catch (parseError) {
              console.error('‚ùå JSON parse error:', parseError);
              resolve({
                decision: 'APPROVED',
                reasoning: 'Parse error, auto-approved',
                score: 75,
              });
            }
          }
        } catch (error) {
          console.error('‚ùå Error processing message:', error);
        }
      });

      ws.on('error', (error) => {
        console.error('‚ùå WebSocket error:', error);
        clearTimeout(timeout);
        reject(error);
      });

      ws.on('close', () => {
        console.log('üîå WebSocket closed');
        clearTimeout(timeout);

        if (!hasReceivedResponse) {
          resolve({
            decision: 'APPROVED',
            reasoning: 'Connection closed without response',
            score: 75,
          });
        }
      });

    } catch (error) {
      console.error('‚ùå Agent evaluation error:', error);
      reject(error);
    }
  });
}
